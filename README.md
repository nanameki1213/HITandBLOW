# HITandBLOW

C言語でヒットアンドブローを作成する手順を以下に示します。
これまでのC言語の知識を使いながら、足りない部分は補完します。
わからないことがあったら、調べたり聞いたりしてください。

**7/5 prototype.cに、input_arrayの宣言が無かったので追加しました.**

## 完成したゲームを遊んでみる

作り始める前に、ゲームをやってみよう
1. このページの右上、緑色のCodeという部分を押す
2. Download ZIP を選択
3. ZIPをHOME(x:)に展開
4. フォルダ内のhitandblow_with_function.cをCpadで開き、実行

## ゲームを実装するために何が必要か考えてみる

コードを書き始める前に、ゲームの進行がどうなるかを考えていきましょう。

prototype.cを開いてください。ゲームのプロトタイプ(原形)が書かれているので、このプロトタイプに手を加えて、完成させます。
1.から5.までを順番に実装していき、最後につなげて完成させます。

### プロトタイプの説明

prototype.c内の、1.から5.までをひとつづつ完成させていきます。
コードを書く前に、既に書かれている部分の説明を行います。

#### 変数の説明

このゲームを作るうえで、どのような変数が必要になってくるでしょうか
プロトタイプのコードで、既に変数宣言を行っているので、その解説をしていきたいと思います。
```prototype.c
int main(void) {
  int ans[DIGITS_NUM];
  int i, j;
  int hit_num = 0, blow_num = 0;
```
main関数内の初めの2行は、変数宣言が行われています。正解の3桁を格納するansという名前のint型配列と、繰返しのインデックスとして後々使うiとjを宣言しています。DIGITS_NUMについては後述します。さらに、hit_num, blow_numはそれぞれヒット数、ブロー数を格納するために用意しています。hit_num, blow_numについては、後にカウントを行うため、0で初期化しています。
```prototype.c
while(/* プレイヤーが正解しない間 */) {
    int input_array[DIGITS_NUM];
    int input;
```
ゲームの進行部分にあたるループの中でも、変数宣言が行われています。プレイヤーから入力された3桁の数字を格納するint型変数inputと、inputの各桁の数字を格納するための3つの要素を持つint型の配列input_arrayを宣言しています。この二つの使い分けについては後述します。

ここまでの変数をまとめると、以下の様になります。
| 変数名 | 役割 |
| ---- | ---- |
| ans | 正解を格納 |
| input | プレイヤーの回答を格納 | 
| input_array | inputの各桁の数字を格納 |
| i | 繰り返しのインデックスとして使用 |
| j | 繰り返しのインデックスとして使用 |
| hit_num | ヒット数を格納 |
| blow_num | ブロー数を格納 |

#### プリプロセス部分の説明
```prototype.c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define DIGITS_NUM 3
```
このコードの始めには、いつもの定型文である#include <stdio.h>に加えて、いろいろなものが書いてあります。特徴は、すべて文頭に#がついていることです。C言語では文頭に#がつく文は特別で、普通のC言語の文(printfなど)がコンパイラによって処理されるのに対して、#がつく文はプリプロセッサと呼ばれるものに処理されます。英語で接頭辞プリ(pre)は、前という意味があります。つまり、プリプロセッサとは、コンパイラによる処理の前に行われる処理、ということになります。ここでは#includeと#defineのみ簡単に説明します。
##### #include
#include は、指定されたファイルを読み込みます。例えば#include <stdio.h>では、stdio.hというファイルをどこかから引っ張ってきて、このファイルに展開しているということです。stdio.hにはいったい何が入っているのでしょうか。いつも使っているprintfやscanfなどです。stdio、とは、standard input/outputを略したファイル名で、その名の通り、基本的な入出力の関数たちを格納しています。stdio.hを#includeで読み込むことで、printやscanfを読み込んでいることになります。逆に言えば、これをincludeしないと、それらの関数は使えないということです。C言語単体では、画面表示の機能まではサポートしていません。今回のプログラムでは事情によりstdio.hだけでなくstdlib.h、time.hもincludeしています。

##### #define
今回のプログラムで本当に大事なのはこっちです。#defineとは、マクロ機能などとも呼ばれ、プログラム中の文字列をあらかじめ定義した規則にしたがって置換する機能です。定数として考えると手っ取り早く理解できると思います。マクロ機能があるとなぜいいのかをストーリーで示します。
```prototype.c
#include <stdio.h>

int main(void) {
  int ans[3];
  return 0;
}
```
このプログラムは、要素数3のint型配列を宣言します。この3という数字は桁数を表しているのです。しかしこの説明なしにいきなりプログラムを見せられると、この3という数字が何を意味しているのかわかりません。マクロ機能を使って同じことをするプログラムを次に示します。
```prototype.c
#include <stdio.h>
#define DIGITS_NUM 3

int main(void) {
  int ans[DIGITS_NUM];
  return 0;
}
```
DIGITS_NUMというマクロを追加して、配列の宣言に用いています。DIGITS_NUMとは、翻訳すると桁数です。これにより、プログラムが幾分みやすくなりました。

## ゲームの実装

ここからプログラムを作成していきます。実装するときに気にかけてほしい事は、できるだけ汎用性を保つことです。具体的に言うと、いまゲームの数字の桁数は3桁ですが、難易度を求めて4桁、5桁の数字を当てたいと思ったとき、DIGITS_NUMの3という数字を4、5に変えるだけで他は何も変えなくてもいいという状態を目指してください。

### 答えとなる数を設定する

ここからゲームの実装に入っていきます。まずは「1.答えとなる数を設定する」です。このゲームの答えはランダムで設定されるようになっています。しかし、いきなりランダムな答えを生成するコードを書くのは難しいので、とりあえず最初は何回遊んでも答えが毎回同じという仕様にしましょう。このようにゲームの実装は、最低限ゲームが完成するところまでもっていき、それから答えをランダムにするなどの機能を追加で実装していくことにします。さて、答えはansというint型配列に格納されるのでした。ansの各要素に数を代入してあげれば、答えを設定できそうです。しかし、ヒットアンドブローというゲームの性質上、答えとなる数の各桁の数は重複が許されないのでした。例えば121とか334のような数は答えに設定しないようにします。

### プレイヤーからの数の入力を行う

プレイヤーからの入力を行います。答えを設定した時と同様に、プレイヤーからの入力も重複があってはなりません。実装はを簡潔にするため、重複を検知する機能を実装するのは後からにして、とりあえず最初はプレイヤーがミスをしないことを祈ることにしましょう。プレイヤーからの入力は2段階で行われます。
1. 3桁の数字をscanfでinputに入力
2. inputから配列input_arrayに変換

1.は普通に数をscanfで読み取ってください。3桁以上の数や3桁未満の数を入力された場合の事は今は考えなくていいです。プレイヤーに任せましょう。
2.が難関になると思います。3桁の数字の各桁の値を計算して、input_arrayに順になるように格納してください。たとえばinputが123のとき、input_arrya[0]は1、input_arrya[1]は2、input_arrya[2]は3になるようにしてください。

### 入力された数のヒット数を計算

プレイヤーからの入力と正解を照らし合わせてヒット数を算出します。ヒットとは、数も場所もあっている状態の数でした。つまり、for文で正解と回答の二つの配列を走査して、一致している数だけカウントすれば良さそうですね。

### 入力された数のブロー数を計算

同様に、ブロー数を計算します。ブロー数は、数は一致しているが、場所が一致していないような数です。そのため、ヒット数より計算が複雑になります。ヒントは2重ループを使います。

### 結果を表示

正解しているかどうかを判定し、正解していれば正解!と出力、不正解ならヒット数、ブロー数を表す変数をprintfで出力します。正解かどうかを判断するにはどうすればいいでしょうか。正解している時のヒット数とブロー数の状態を考えてみましょう。正解しているということは、全ヒットということなので、ヒット数と桁数が一致している状態が、正解の時ということになります。

## ゲームの実装(答え)

ここからは1~5の実装例を示していきます。

### 答えとなる数を設定する

```hitandblow.c
// 1. 答えとなる数を設定する
// 正解: 123
ans[0] = 3;
ans[1] = 2;
ans[2] = 1;
```

正解の配列であるansの各要素に、数字を代入しています。```// 正解: 123```とあるように、今回正解の数は123にしました。あくまで実装例なので、正解の数は自分で決めてください。

### プレイヤーからの数の入力を行う

```hitandblow.c
printf("%d桁の整数を入力: ", DIGITS_NUM);
scanf("%d", &input);
for(i = 0; i < DIGITS_NUM; i++) {
	input_array[i] = input%10;
	input = input / 10;
}
```

プレイヤーからの入力は、2段階に分けて行うことを前に説明しました。改めてその段階を次に示します。
1. 3桁の数字をscanfでinputに入力
2. inputから配列input_arrayに変換

プログラムの2行目が1.に当たる箇所です。ここについては特に説明は不要でしょう。
では2.を考えてみましょう。inputの各桁を計算で求めます。
まず一桁目は、inputを10で割った余りで求められます。実際に計算して確認してください。次に、二桁目を求めるために、inputを10で割ります。その後、再びinputを10で割った余りを計算すると、二桁目の値が得られます。
三桁目もinputを10で割ったあとに、さらに10で割った余りを求めることで得られます。
この手順をC言語で書くと、3から6行目の様になります。
まずはfor文を見てみましょう。4行目を抜き出すと、```for(i = 0; i < DIGITS_NUM; i++) {```とあります。これから、このfor文はDIGITS_NUM回繰返しを行うということがわかると思います。
次に、for文の中身を見ていきます。```input%10```でinputを10で割った余りを算出し、その値を```input_array[i]```に代入しています。
その後、```input = input / 10;```でinputを10で割っています。

### 入力された数のヒット数を計算

```hitandblow.c
for(i = 0; i < DIGITS_NUM; i++) {
  if(input_array[i] == ans[i]) {
    hit_num++;
  }
}
```

ヒット数の計算は、input_arrayとansの要素が一致している数をカウントします。
配列の全要素にアクセスするために、DIGITS_NUM回繰り返すfor文を記述します。for文内では、iを使ってinput_arrayとansにアクセスし、if文を使って一致しているかどうかの判定を行います。
そして、もし一致していたら、ヒット数を格納する変数hit_numを更新し、1プラスします。

### 入力された数のブロー数を計算

```hitandblow.c
for(i = 0; i < DIGITS_NUM; i++) {
  for(j = 0; j < DIGITS_NUM; j++) {
    if(ans[i] == input_array[j]) {
      if(i != j) {
        blow_num++;
      }
    }
  }
}
```

ブロー数の計算では、2重ループを使用します。コードをよく追って見てください。ansの各要素ごとに、inputの全要素と比較する処理を書く必要があります。 

### 結果を表示

```hitandblow.c
if(hit_num == DIGITS) {
  printf("正解!\n");
  break;
}
printf("hit: %d, blow: %d\n\n", hit_num, blow_num);
```

前までに得られたヒット数、ブロー数をもとに、結果を表示します。if文でhit_numの数がDIGITS_NUMと一致しているかを判定、すなわち正解しているかどうかを判定し、正解していたら"正解!"と出力して、while文をbreak;で抜けます。もし正解していなければ、while文を抜けずに、その次のprintf文でhit_numとblow_numを出力します。

### ループの終了条件

1~5までを実装したら、プレイヤーの回答が一回行える処理がかけました。あとはこれをプレイヤーが正解するまで繰り返すだけです。prototype.cではすでにwhile文が記述されています。このwhile文の継続条件は"プレイヤーが正解しない間"です。しかしすでに"5.結果を表示する"で、正解しているかどうかの判定を行ってwhile文を抜けるかどうかは実装済みなので、```while(1)```のようにして無限ループ状態にします。

## ひとまず完成
ひとまず完成しました。1~5の断片的なコードを繋げたものを次に載せます(hitandblow_beta.c)
```hitandblow_beta.c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define DIGITS_NUM 3

int main(void) {
  int ans[DIGITS_NUM];
  int i, j;
  int hit_num = 0, blow_num = 0;
  int input;

  srand((unsigned)time(NULL));

  // 1. 答えとなる数を設定する
  ans[0] = 3;
  ans[1] = 2;
  ans[2] = 1;

  while(1) {
    int input_array[DIGITS_NUM];
    int hit_num = 0, blow_num = 0;

    // 2. プレイヤーからの数の入力を行う
    printf("%d桁の整数を入力: ", DIGITS_NUM);
    scanf("%d", &input);
    for(i = 0; i < DIGITS_NUM; i++) {
      input_array[i] = input%10;
      input = input / 10;
    }

    // 3. 入力された数のヒット数を計算
    for(i = 0; i < DIGITS_NUM; i++) {
      if(input_array[i] == ans[i]) {
        hit_num++;
      }
    }

    // 4. 入力された数のブロー数を計算
    for(i = 0; i < DIGITS_NUM; i++) {
      for(j = 0; j < DIGITS_NUM; j++) {
        if(ans[i] == input_array[j]) {
          if(i != j) {
            blow_num++;
          }
        }
      }
    }

    // 5. 結果を表示
    printf("hit: %d, blow: %d\n\n", hit_num, blow_num);

  }

  return 0;
}
```

## 答えをランダムに決める

答えとなる数をランダムになるようにします。答えとなる数にかかっている制限は次の通りです。
* DIGITS_NUM桁
* 重複なしの値
これらを満たす数を自動で生成するプログラムを作成していきます。

答えを格納する変数ansは配列なので、その要素にひとつづつ値を入れていく必要があります。
C言語で乱数を得るためには、randという関数を使います。次にサンプルコードを示します。
```rand.c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main(void) {

  srand((unsigned)time(NULL));

  // 適当な乱数を表示
  printf("乱数: %d\n", rand());

  // 0~9までの範囲で乱数を生成
  int a = rand()%9;
  printf("0~9の範囲の乱数: %d\n", a);

  return 0;
}
```

rand関数を使うと、適当な大きさ(最大RAND_MAX)の乱数を得ることができます。
またrand関数でよく使われる方法として、ある数で割った余りを用いて、その割った数の範囲内の乱数を生成するというものがあります。例えば、サンプルコード内の```rand()%9```では、0~9までの乱数を得ています。サンプルコードでは、他にも見慣れない文として
```rand.c
#include <stdio.h>
#include <time.h>
srand((unsigned)time(NULL));
```
があります。これは、rand関数を使う時には必ず書く必要がある文です。

さて、rand関数の使い方がわかったところで、答えを生成するプログラムを考えてみましょう。while文を使って、ansの全要素に0~9までのランダムな数字を代入するプログラムを以下に示します。

```set_ans.c
// 1. 答えとなる数を設定する
i = 0;
while(i < DIGITS_NUM) {
  ans[i] = rand()%9;
  i++;
}
```

まずインデックスとして用いるiを0で初期化し、その後while文で、DIGITS_NUM回繰り返しを行い、ansの各要素にrand()%9で生成した0から9までの乱数を代入していきます。これではまだ重複を許すプログラムとなってしまっています。値の重複を許さないようにするにはどうすればいいでしょうか。

1つの解決法として、もしwhile文の途中で数が重複したら、そこの要素だけもう一度乱数を生成しなおして重複を防ぐ方法があります。例えば、
whileのループ1回目のrand()%9: 5
whileのループ2回目のrand()%9: 5
と、重複した値が生成された場合、その時点で重複を検知し、乱数を再生成して設定する、というような具合です。

重複を検知するためには、既に使われた数を管理する必要があります。新たに管理するための配列を次のように宣言します。
```illegal_num.c
int illegal_num[10] = {0};
```
新たに宣言した変数illegal_numは、10個の要素をもつint型の配列です。illegal_numの全要素は0で初期化します(初期化で{0}と書くと配列を0で初期化することを意味します)。この配列は、0~9までの10個の数の中で、既に使われた数とそうでない数とを管理します。10個の要素を持つ配列なので、illegal_num[0]からillegal_num[9]までが有効な要素です。要素の数が1の場合、その要素に対応する要素番号はすでに使われているという意味を持たせます。例えば、illegal_num[3]の中身が1だった場合、既に3という数は使用されていることになります。illegal_numを使って、重複を防ぐためには、whileループの中身で、ランダムに出た0から9までの値に対して、
1. illegal_numの当該する要素の中身が1であるかどうかを確認する、すなわち、その数がすでに使われているかどうかを確認する
2. もしまだ使われていない数だったら、ans[i]に値を代入後、illegal_numの当該する要素の中身を1にして、その数を既に使われた数として登録する
3. もし、既に使われている数として登録されていたら未登録の数が出るまで再度乱数を生成する
という3つの処理を追加します。1.から3.までの一連の処理は、if文を使った分岐処理を行うことで実装できそうです。3.に関しては難しいので、1.と2.の実装を考えてみてください。
実装例として、重複なしのDIGITS_NUM桁のランダムの値を生成するプログラムを次に示します。

```random_ans.c
i = 0;
int illegal_num[9] = {0};
while(i < DIGITS_NUM) {
	ans[i] = rand()%9;
	if(illegal_num[ans[i]] == 1) {
		continue;
	}
	illegal_num[ans[i]] = 1;
	i++;
}
```

whileループの中身を重複を防ぐ前のプログラムと比べてみると、最初```ans[i] = rand()%9;```と最後```i++;```の間に数行追加されていることが分かります。if文をみてみましょう。```if(illegal_num[ans[i]] == 1)```制御式では配列へのアクセス方法が少し複雑になっています。制御式を読み解くと、「illegal_numの配列のans[i]番目の要素の中身が1かどうか」という感じになります。

## エラー処理を追加


## 対戦機能を追加

ここから対戦機能を追加していきます。
プレイヤーの数を二人に増やします。さらにターンの要素を増やして、先手後手のルールも追加します。
