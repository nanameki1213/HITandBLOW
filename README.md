# HITandBLOW

C言語でヒットアンドブローを作成する手順を以下に示します。
これまでのC言語の知識を使いながら、足りない部分は補完します。
わからないことがあったら、調べたり聞いたりしてください。

**7/5 prototype.cに、input_arrayの宣言が無かったので追加しました.**

## 完成したゲームを遊んでみる

作り始める前に、ゲームをやってみよう
1. このページの右上、緑色のCodeという部分を押す
2. Download ZIP を選択
3. ZIPをHOME(x:)に展開
4. フォルダ内のhitandblow_with_function.cをCpadで開き、実行

## ゲームを実装するために何が必要か考えてみる

コードを書き始める前に、ゲームの進行がどうなるかを考えていきましょう。

prototype.cを開いてください。ゲームのプロトタイプ(原形)が書かれているので、このプロトタイプに手を加えて、完成させます。
1.から5.までを順番に実装していき、最後につなげて完成させます。

### プロトタイプの説明

prototype.c内の、1.から5.までをひとつづつ完成させていきます。
コードを書く前に、既に書かれている部分の説明を行います。

#### 変数の説明

このゲームを作るうえで、どのような変数が必要になってくるでしょうか
プロトタイプのコードで、既に変数宣言を行っているので、その解説をしていきたいと思います。
```prototype.c
int main(void) {
  int ans[DIGITS_NUM];
  int i, j;
  int hit_num = 0, blow_num = 0;
```
main関数内の初めの2行は、変数宣言が行われています。正解の3桁を格納するansという名前のint型配列と、繰返しのインデックスとして後々使うiとjを宣言しています。DIGITS_NUMについては後述します。さらに、hit_num, blow_numはそれぞれヒット数、ブロー数を格納するために用意しています。hit_num, blow_numについては、後にカウントを行うため、0で初期化しています。
```prototype.c
while(/* プレイヤーが正解しない間 */) {
    int input_array[DIGITS_NUM];
    int input;
```
ゲームの進行部分にあたるループの中でも、変数宣言が行われています。プレイヤーから入力された3桁の数字を格納するint型変数inputと、inputの各桁の数字を格納するための3つの要素を持つint型の配列input_arrayを宣言しています。この二つの使い分けについては後述します。

ここまでの変数をまとめると、以下の様になります。
| 変数名 | 役割 |
| ---- | ---- |
| ans | 正解を格納 |
| input | プレイヤーの回答を格納 | 
| input_array | inputの各桁の数字を格納 |
| i | 繰り返しのインデックスとして使用 |
| j | 繰り返しのインデックスとして使用 |
| hit_num | ヒット数を格納 |
| blow_num | ブロー数を格納 |

#### プリプロセス部分の説明
```prototype.c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define DIGITS_NUM 3
```
このコードの始めには、いつもの定型文である#include <stdio.h>に加えて、いろいろなものが書いてあります。特徴は、すべて文頭に#がついていることです。C言語では文頭に#がつく文は特別で、普通のC言語の文(printfなど)がコンパイラによって処理されるのに対して、#がつく文はプリプロセッサと呼ばれるものに処理されます。英語で接頭辞プリ(pre)は、前という意味があります。つまり、プリプロセッサとは、コンパイラによる処理の前に行われる処理、ということになります。ここでは#includeと#defineのみ簡単に説明します。
##### #include
#include は、指定されたファイルを読み込みます。例えば#include <stdio.h>では、stdio.hというファイルをどこかから引っ張ってきて、このファイルに展開しているということです。stdio.hにはいったい何が入っているのでしょうか。いつも使っているprintfやscanfなどです。stdio、とは、standard input/outputを略したファイル名で、その名の通り、基本的な入出力の関数たちを格納しています。stdio.hを#includeで読み込むことで、printやscanfを読み込んでいることになります。逆に言えば、これをincludeしないと、それらの関数は使えないということです。C言語単体では、画面表示の機能まではサポートしていません。今回のプログラムでは事情によりstdio.hだけでなくstdlib.h、time.hもincludeしています。

##### #define
今回のプログラムで本当に大事なのはこっちです。#defineとは、マクロ機能などとも呼ばれ、プログラム中の文字列をあらかじめ定義した規則にしたがって置換する機能です。定数として考えると手っ取り早く理解できると思います。マクロ機能があるとなぜいいのかをストーリーで示します。
```prototype.c
#include <stdio.h>

int main(void) {
  int ans[3];
  return 0;
}
```
このプログラムは、要素数3のint型配列を宣言します。この3という数字は桁数を表しているのです。しかしこの説明なしにいきなりプログラムを見せられると、この3という数字が何を意味しているのかわかりません。マクロ機能を使って同じことをするプログラムを次に示します。
```prototype.c
#include <stdio.h>
#define DIGITS_NUM 3

int main(void) {
  int ans[DIGITS_NUM];
  return 0;
}
```
DIGITS_NUMというマクロを追加して、配列の宣言に用いています。DIGITS_NUMとは、翻訳すると桁数です。これにより、プログラムが幾分みやすくなりました。

## ゲームの実装

ここからプログラムを作成していきます。実装するときに気にかけてほしい事は、できるだけ汎用性を保つことです。具体的に言うと、いまゲームの数字の桁数は3桁ですが、難易度を求めて4桁、5桁の数字を当てたいと思ったとき、DIGITS_NUMの3という数字を4、5に変えるだけで他は何も変えなくてもいいという状態を目指してください。

### 答えとなる数を設定する

ここからゲームの実装に入っていきます。まずは「1.答えとなる数を設定する」です。このゲームの答えはランダムで設定されるようになっています。しかし、いきなりランダムな答えを生成するコードを書くのは難しいので、とりあえず最初は何回遊んでも答えが毎回同じという仕様にしましょう。このようにゲームの実装は、最低限ゲームが完成するところまでもっていき、それから答えをランダムにするなどの機能を追加で実装していくことにします。さて、答えはansというint型配列に格納されるのでした。ansの各要素に数を代入してあげれば、答えを設定できそうです。しかし、ヒットアンドブローというゲームの性質上、答えとなる数の各桁の数は重複が許されないのでした。例えば121とか334のような数は答えに設定しないようにします。

### プレイヤーからの数の入力を行う

プレイヤーからの入力を行います。答えを設定した時と同様に、プレイヤーからの入力も重複があってはなりません。実装はを簡潔にするため、重複を検知する機能を実装するのは後からにして、とりあえず最初はプレイヤーがミスをしないことを祈ることにしましょう。プレイヤーからの入力は2段階で行われます。
1. 3桁の数字をscanfでinputに入力
2. inputから配列input_arrayに変換

1.は普通に数をscanfで読み取ってください。3桁以上の数や3桁未満の数を入力された場合の事は今は考えなくていいです。プレイヤーに任せましょう。
2.が難関になると思います。3桁の数字の各桁の値を計算して、input_arrayに順になるように格納してください。たとえばinputが123のとき、input_arrya[0]は1、input_arrya[1]は2、input_arrya[2]は3になるようにしてください。

### 入力された数のヒット数を計算

プレイヤーからの入力と正解を照らし合わせてヒット数を算出します。ヒットとは、数も場所もあっている状態の数でした。つまり、for文で正解と回答の二つの配列を走査して、一致している数だけカウントすれば良さそうですね。

### 入力された数のブロー数を計算

同様に、ブロー数を計算します。ブロー数は、数は一致しているが、場所が一致していないような数です。そのため、ヒット数より計算が複雑になります。ヒントは2重ループを使います。

### 結果を表示

正解しているかどうかを判定し、正解していれば正解!と出力、不正解ならヒット数、ブロー数を表す変数をprintfで出力します。正解かどうかを判断するにはどうすればいいでしょうか。正解している時のヒット数とブロー数の状態を考えてみましょう。正解しているということは、全ヒットということなので、ヒット数と桁数が一致している状態が、正解の時ということになります。

## ゲームの実装(答え)

ここからは1~5の実装例を示していきます。

### 答えとなる数を設定する

```hitandblow.c
// 1. 答えとなる数を設定する
// 正解: 123
ans[0] = 3;
ans[1] = 2;
ans[2] = 1;
```

正解の配列であるansの各要素に、数字を代入しています。```// 正解: 123```とあるように、今回正解の数は123にしました。あくまで実装例なので、正解の数は自分で決めてください。

### プレイヤーからの数の入力を行う

```hitandblow.c
printf("%d桁の整数を入力: ", DIGITS_NUM);
scanf("%d", &input);
for(i = 0; i < DIGITS_NUM; i++) {
	input_array[i] = input%10;
	input = input / 10;
}
```

プレイヤーからの入力は、2段階に分けて行うことを前に説明しました。改めてその段階を次に示します。
1. 3桁の数字をscanfでinputに入力
2. inputから配列input_arrayに変換

プログラムの2行目が1.に当たる箇所です。ここについては特に説明は不要でしょう。
では2.を考えてみましょう。inputの各桁を計算で求めます。
まず一桁目は、inputを10で割った余りで求められます。実際に計算して確認してください。次に、二桁目を求めるために、inputを10で割ります。その後、再びinputを10で割った余りを計算すると、二桁目の値が得られます。
三桁目もinputを10で割ったあとに、さらに10で割った余りを求めることで得られます。
この手順をC言語で書くと、3から6行目の様になります。
まずはfor文を見てみましょう。4行目を抜き出すと、```for(i = 0; i < DIGITS_NUM; i++) {```とあります。これから、このfor文はDIGITS_NUM回繰返しを行うということがわかると思います。
次に、for文の中身を見ていきます。```input%10```でinputを10で割った余りを算出し、その値を```input_array[i]```に代入しています。
その後、```input = input / 10;```でinputを10で割っています。

### 入力された数のヒット数を計算

```hitandblow.c
for(i = 0; i < DIGITS_NUM; i++) {
  if(input_array[i] == ans[i]) {
    hit_num++;
  }
}
```

ヒット数の計算は、input_arrayとansの要素が一致している数をカウントします。
配列の全要素にアクセスするために、DIGITS_NUM回繰り返すfor文を記述します。for文内では、iを使ってinput_arrayとansにアクセスし、if文を使って一致しているかどうかの判定を行います。
そして、もし一致していたら、ヒット数を格納する変数hit_numを更新し、1プラスします。

### 入力された数のブロー数を計算

```hitandblow.c
for(i = 0; i < DIGITS_NUM; i++) {
  for(j = 0; j < DIGITS_NUM; j++) {
    if(ans[i] == input_array[j]) {
      if(i != j) {
        blow_num++;
      }
    }
  }
}
```

ブロー数の計算では、2重ループを使用します。コードをよく追って見てください。ansの各要素ごとに、inputの全要素と比較する処理を書く必要があります。 

### 結果を表示

```hitandblow.c
if(hit_num == DIGITS) {
  printf("正解!\n");
  break;
}
printf("hit: %d, blow: %d\n\n", hit_num, blow_num);
```

前までに得られたヒット数、ブロー数をもとに、結果を表示します。if文でhit_numの数がDIGITS_NUMと一致しているかを判定、すなわち正解しているかどうかを判定し、正解していたら"正解!"と出力して、while文をbreak;で抜けます。もし正解していなければ、while文を抜けずに、その次のprintf文でhit_numとblow_numを出力します。

### ループの終了条件

1~5までを実装したら、プレイヤーの回答が一回行える処理がかけました。あとはこれをプレイヤーが正解するまで繰り返すだけです。prototype.cではすでにwhile文が記述されています。このwhile文の継続条件は"プレイヤーが正解しない間"です。しかしすでに"5.結果を表示する"で、正解しているかどうかの判定を行ってwhile文を抜けるかどうかは実装済みなので、```while(1)```のようにして無限ループ状態にします。

## ひとまず完成
ひとまず完成しました。1~5の断片的なコードを繋げたものを次に載せます(hitandblow_beta.c)
```hitandblow_beta.c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define DIGITS_NUM 3

int main(void) {
  int ans[DIGITS_NUM];
  int i, j;
  int hit_num = 0, blow_num = 0;
  int input;

  srand((unsigned)time(NULL));

  // 1. 答えとなる数を設定する
  ans[0] = 3;
  ans[1] = 2;
  ans[2] = 1;

  while(1) {
    int input_array[DIGITS_NUM];
    int hit_num = 0, blow_num = 0;

    // 2. プレイヤーからの数の入力を行う
    printf("%d桁の整数を入力: ", DIGITS_NUM);
    scanf("%d", &input);
    for(i = 0; i < DIGITS_NUM; i++) {
      input_array[i] = input%10;
      input = input / 10;
    }

    // 3. 入力された数のヒット数を計算
    for(i = 0; i < DIGITS_NUM; i++) {
      if(input_array[i] == ans[i]) {
        hit_num++;
      }
    }

    // 4. 入力された数のブロー数を計算
    for(i = 0; i < DIGITS_NUM; i++) {
      for(j = 0; j < DIGITS_NUM; j++) {
        if(ans[i] == input_array[j]) {
          if(i != j) {
            blow_num++;
          }
        }
      }
    }

    // 5. 結果を表示
    printf("hit: %d, blow: %d\n\n", hit_num, blow_num);

  }

  return 0;
}
```

## 答えをランダムに決める

答えとなる数をランダムになるようにします。答えとなる数にかかっている制限は次の通りです。
* DIGITS_NUM桁
* 重複なしの値
これらを満たす数を自動で生成するプログラムを作成していきます。

答えを格納する変数ansは配列なので、その要素にひとつづつ値を入れていく必要があります。
C言語で乱数を得るためには、randという関数を使います。次にサンプルコードを示します。
```rand.c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main(void) {

  srand((unsigned)time(NULL));

  // 適当な乱数を表示
  printf("乱数: %d\n", rand());

  // 0~9までの範囲で乱数を生成
  int a = rand()%9;
  printf("0~9の範囲の乱数: %d\n", a);

  return 0;
}
```

rand関数を使うと、適当な大きさ(最大RAND_MAX)の乱数を得ることができます。
またrand関数でよく使われる方法として、ある数で割った余りを用いて、その割った数の範囲内の乱数を生成するというものがあります。例えば、サンプルコード内の```rand()%9```では、0~9までの乱数を得ています。サンプルコードでは、他にも見慣れない文として
```rand.c
#include <stdio.h>
#include <time.h>
srand((unsigned)time(NULL));
```
があります。これは、rand関数を使う時には必ず書く必要がある文です。

さて、rand関数の使い方がわかったところで、答えを生成するプログラムを考えてみましょう。while文を使って、ansの全要素に0~9までのランダムな数字を代入するプログラムを以下に示します。

```set_ans.c
// 1. 答えとなる数を設定する
i = 0;
while(i < DIGITS_NUM) {
  ans[i] = rand()%9;
  i++;
}
```

まずインデックスとして用いるiを0で初期化し、その後while文で、DIGITS_NUM回繰り返しを行い、ansの各要素にrand()%9で生成した0から9までの乱数を代入していきます。これではまだ重複を許すプログラムとなってしまっています。値の重複を許さないようにするにはどうすればいいでしょうか。

1つの解決法として、もしwhile文の途中で数が重複したら、そこの要素だけもう一度乱数を生成しなおして重複を防ぐ方法があります。例えば、
whileのループ1回目のrand()%9: 5
whileのループ2回目のrand()%9: 5
と、重複した値が生成された場合、その時点で重複を検知し、乱数を再生成して設定する、というような具合です。

重複を検知するためには、既に使われた数を管理する必要があります。新たに管理するための配列を次のように宣言します。
```illegal_num.c
int illegal_num[10] = {0};
```
新たに宣言した変数illegal_numは、10個の要素をもつint型の配列です。illegal_numの全要素は0で初期化します(初期化で{0}と書くと配列を0で初期化することを意味します)。この配列は、0~9までの10個の数の中で、既に使われた数とそうでない数とを管理します。10個の要素を持つ配列なので、illegal_num[0]からillegal_num[9]までが有効な要素です。要素の数が1の場合、その要素に対応する要素番号はすでに使われているという意味を持たせます。例えば、illegal_num[3]の中身が1だった場合、既に3という数は使用されていることになります。illegal_numを使って、重複を防ぐためには、whileループの中身で、ランダムに出た0から9までの値に対して、
1. illegal_numの当該する要素の中身が1であるかどうかを確認する、すなわち、その数がすでに使われているかどうかを確認する
2. もしまだ使われていない数だったら、ans[i]に値を代入後、illegal_numの当該する要素の中身を1にして、その数を既に使われた数として登録する
3. もし、既に使われている数として登録されていたら未登録の数が出るまで再度乱数を生成する
という3つの処理を追加します。1.から3.までの一連の処理は、if文を使った分岐処理を行うことで実装できそうです。3.に関しては難しいので、1.と2.の実装を考えてみてください。
実装例として、重複なしのDIGITS_NUM桁のランダムの値を生成するプログラムを次に示します。

```random_ans.c
// 1. 答えとなる数を設定する
i = 0;
int illegal_num[9] = {0};
while(i < DIGITS_NUM) {
	ans[i] = rand()%9;
	if(illegal_num[ans[i]] == 1) {
		continue;
	}
	illegal_num[ans[i]] = 1;
	i++;
}
```

whileループの中身を重複を防ぐ前のプログラムと比べてみると、最初```ans[i] = rand()%9;```と最後```i++;```の間に数行追加されていることが分かります。if文をみてみましょう。```if(illegal_num[ans[i]] == 1)```このif文の制御式は配列へのアクセス方法が少し複雑になっています。制御式を直訳(?)すると、「illegal_numの配列のans[i]番目の要素の中身が1かどうか」という感じになります。わかりにくですね。もう少しかみ砕いて意訳してみると、「生成した0から9までの範囲の乱数が、すでに使われた数として登録されているかどうか」みたいな感じになるでしょうか。このif文の直前には、ans[i]に0から9までの乱数が代入されています。そのため、```illegal_num[ans[i]]```は、illegal_numの乱数番目の要素にアクセスすることになります。

## 関数を使う

### ソースコードの見やすさ

ここまでのコードを見てみましょう

```hitandblow_beta.c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define DIGITS_NUM 3

int main(void) {
  int ans[DIGITS_NUM];
  int i, j;
  int hit_num = 0, blow_num = 0;
  int input;

  srand((unsigned)time(NULL));

  // 1. 答えとなる数を設定する
  i = 0;
  int illegal_num[9] = {0};
  while(i < DIGITS_NUM) {
    ans[i] = rand()%9;
    if(illegal_num[ans[i]] == 1) {
      continue;
    }
    illegal_num[ans[i]] = 1;
    i++;
  }

  while(1) {
    int input_array[DIGITS_NUM];
    int hit_num = 0, blow_num = 0;

    // 2. プレイヤーからの数の入力を行う
    printf("%d桁の整数を入力: ", DIGITS_NUM);
    scanf("%d", &input);
    for(i = 0; i < DIGITS_NUM; i++) {
      input_array[i] = input%10;
      input = input / 10;
    }

    // 3. 入力された数のヒット数を計算
    for(i = 0; i < DIGITS_NUM; i++) {
      if(input_array[i] == ans[i]) {
        hit_num++;
      }
    }

    // 4. 入力された数のブロー数を計算
    for(i = 0; i < DIGITS_NUM; i++) {
      for(j = 0; j < DIGITS_NUM; j++) {
        if(ans[i] == input_array[j]) {
          if(i != j) {
            blow_num++;
          }
        }
      }
    }

    // 5. 結果を表示
    printf("hit: %d, blow: %d\n\n", hit_num, blow_num);

  }

  return 0;
}
```

さて、このプログラムを初めて読むことになった時のことを考えます。このプログラムは見やすいでしょうか。コメントで、処理の内容が示されているのである程度見やすいかもしれません。
が、もしコメントが無く自分で全部処理を追っていかないといけないときはどうでしょうか。また、このプログラムのmain関数の中(```int main(void){  }の中```)は60行近くありますが、これが1000行になったらどうでしょうか。コメントがあったとしても、処理をほとんどベタ書きしているプログラムを読む気にはなれないでしょう。

prototype.cをもう一度見直してください。main関数の中はたったの24行です。コメントしかないので短いのは当たり前ですが、どのように処理が行われるのかがすっきり分かりませんか?

### 関数

C言語には関数という便利な仕様があります。関数とは、ある定められた処理を実行する機能の事です。また、関数には引数と戻り値があります。引数とは、関数に与える値の事で、戻り値とは、関数から得られる値です。

引数と戻り値に関しては、数学の関数に例えて説明したいと思います。
y= x^2という関数では、xに値を代入すると、yにxを2乗した値が計算されます。引数はxで、戻り値はyです。
数学の様に常にy(戻り値)があるわけではなく、戻り値がない関数もあるということを覚えて置いてください。

プログラミングでは、長すぎるコードをある程度の処理ごとに区切って関数化し、プログラムを簡潔にすることがよくあります。「ある程度の処理」とは、例えばprototype.cの1から5の処理です。

関数はこのように便利な反面、if文やwhile文よりも構文が難しいです。

関数を使うためには、その関数を定義する必要があります。関数を定義する、つまりその関数が一体どんな関数なのかを設計するということです。関数を設計するためには、次の事を決めます。
* 関数の名前
  関数を呼び出すときに必要な名前です。その関数が行う処理が伝わるような簡潔な名前を付けます。
* 関数で行う処理
  関数が呼び出された時に行う処理です。関数の本体。
* 引数
　関数に与える値です。引数は普通の変数の様に中身を見たり、代入したりすることができます。関数はこの引数をいかようにも使うことができ、例えば条件分岐で使用したり、引数に対して演算を行うなどします。後で詳しく説明を行います。
* 戻り値の型
  関数が返す値の型です。型は例えばint型やdouble型など、変数の型のことです。

では、試しに関数を設計してみましょう。
ある値の2乗を計算する関数を設計したいと思います。名前はsqr、引数としてxという名前のint型変数を受け取るようにして、戻り値の型はint型です。関数の本体は、受け取ったxを2乗する処理、と決めます。
今決めたこの設計をC言語の形に書き下します。すると次のようになります。

```sqr.c
int sqr(int x) {
  int y;
  y = x * x;
  return y;
}
```

先ほどの関数の設計が、どのように記述されているでしょうか。まず名前は、sqrという文字列が見えますね。引数としてint型のxを決めていたはずですが、関数名sqrのすぐ後の()のなかがその宣言をしているようです。戻り値の型の情報はどこに記述があるでしょうか。これは一番最初のintが該当します。残るは関数本体ですが、これは{}の中身です。```x * x```で2乗の計算をしています。そして関数内で宣言したyに計算値を代入し、returnで戻り値として返しています。関数本体には、if文やfor文を書くこともできます。また、引数も1つ以上設定することができます。それに対して、戻り値は1つしかありません。

この関数定義のための記述を一般化すると、次のようになります。

```
戻り値型 関数名(引数1, 引数2, ... , 引数n) {

  関数本体

}
```

もう少しだけ関数定義の例を見てみましょう。先ほどのsqrは実に数学的な関数でしたが、どんな処理を行わせてもいいのです。次は受け取った引数の中身を出力する関数を定義します。いきなりC言語のコードを示しますが慣れてください。

```print_arg.c
#include <stdio.h>

void print_arg(int a, int b) {
  printf("現在print_arg関数を実行中です\n");

  printf("引数a: %d, 引数b: %d\n", a, b);
}
```

この関数は2つの引数が設定されています。関数の本体では、printf関数を使用して、画面に出力を行っています。また戻り値の型には```void```と書かれています。voidと書かれている時には、その関数は何も返さないということを表します。今回のように画面出力だけ行う関数などでは、わざわざ値を返す必要はありません。

これで2つの関数が定義出来ました。これで関数を使う準備は整いました。では関数を使ってみましょう。次のコードを見てください
```function.c
#include <stdio.h>

int sqr(int x) {
  int y;
  y = x * x;
  return y;
}

void print_arg(int a, int b) {
  printf("現在print_arg関数を実行中です\n");

  printf("引数a: %d, 引数b: %d\n", a, b);
}

int main(void) {
  print_arg(1,2);

  int a = sqr(3);
  printf("3の2乗は%dです\n", a);

  return 0;
}
```

さて、いろいろ気づくことがあるかもしれませんが、main関数内を見てください。```print_arg(1,2);```とありますね。定義した関数を呼び出すには、その関数名と引数を書きます。関数呼び出しの文が実行されると、いったんmain関数から離れ、その関数に処理が移ります。そして、関数の処理が終了した後、再びmain関数に戻ってきて、処理が再開されます。このコードでは、print_arg関数に処理が移ります。そして関数本体のprintfが実行されるのです。
次は、sqrの呼び出しです。```int a = sqr(3);```を見てください。これはint型の変数aをsqr(3)の戻り値で初期化する文です。戻り値の型がvoidなprint_argと違って、こちらの関数はint型の値を戻り値にしていました。そのため、sqr(3)を呼び出すと、9を得ることができるのです。そういえば似たようなものがあったのを覚えていますか？rand関数です。実はあれも関数でした。rand関数では、呼び出すとランダムな値を得られるのでした。そのイメージを持ってもらえれば理解しやすいと思います。

ここで引数についても少し説明します。引数と関数内で宣言した変数がどう違うのかというと、引数は宣言と同時に初期化されています。なんの数で初期化されているのかというと、関数呼び出し時に与えられた数です。ここで気を付けてほしいのは、呼び出し側が引数に変数を指定した時の動きです。次のコードを見てください
```arg.c
#include <stdio.h>

void func(int a) {
  a = 10;
}

int main(void) {
  int x = 23;
  func(x);

  printf("x = %d\n", x);
}
```
ここで宣言されているfunc関数は、引数として受け取ったint型のaに10を代入しています。そして処理は終了です。戻り値がvoidで、何も返さない関数です。main関数内では、23で初期化されたint型の変数xを宣言します。そしてfuncをxを引数にして呼び出しています。するとxの中身はどうなるでしょうか?printfでxの値を出力して確かめます。すると、"x = 23"と表示されます。つまり、関数の中でいくら引数の値をいじくろうとも、もとの引数には何の影響もでないということです。これは関数の引数が、"変数そのもの"を渡しているのではなく、"変数の値をコピー"してその値を渡しているからです。

### 標準Cライブラリ

関数は、ここで初めて出てくるわけではありません。実は今まで使ってきたprintfやscanfも関数です。さっき少しネタバレしてしまいましたが、rand関数も関数です。でも、これらの関数を定義した覚えはありません。いつも呼び出しだけ行っていますね。実はこれらは別のファイルで定義されています。stdio.hやstdlib.hというファイルです。これらのファイルの中には大量の関数の定義(正確には関数プロトタイプ宣言)や、オブジェクトマクロ定義(#defineのこと)があります。

これらファイルをまとめて標準Cライブラリと呼びます。ISO(国際標準化機構)という団体で正式にファイルが決められています。

#include <stdio.h>と書くことで、stdio.hファイルの中身を展開して、stdio.hで用意された関数などが使えるようになります。

ちょっと寄り道して、stdio.hのファイルの中から普段使うprintfの関数定義を探してみました。
```stdio.h
/* Write formatted output to stdout.

   This function is a possible cancellation point and therefore not
   marked with __THROW.  */
extern int printf (const char *__restrict __format, ...);
```
いろいろ見慣れないキーワードがでてきています。/* */で囲われている部分はコメントですので、実際の関数定義は最終行のみです。
printfという関数名があるのが分かります。ほかのキーワードについては説明しません。関数の本体はまた別のファイルで定義されています。このように関数本体以外の情報だけをかき、最後に;をつけてとりあえず関数を宣言することを関数原形(プロトタイプ)宣言といいます。

### コードを関数で書き換える

関数の使い方が分かったところで、hitandblowのコードを関数を使って書き換えていきます。以下に書き換え後のコードを示します。長いですがコードを打ち込む事を勧めます。その方が細部まで動きがつかみやすくなるからです。

```hitandblow_with_function_beta.c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define DIGITS_NUM 3

void generate_ans(int ans[]) {
  int i = 0;
	int illegal_num[10] = {0};
	while(i < DIGITS_NUM) {
		ans[i] = rand()%9;
		if(illegal_num[ans[i]] == 1) {
			continue;
		}
		illegal_num[ans[i]] = 1;
		i++;
  }
}

int input_num(int input_array[]) {
  int i;
  int input;
  printf("%d桁の整数を入力: ", DIGITS_NUM);
  scanf("%d", &input);
  for(i = 0; i < DIGITS_NUM; i++) {
    input_array[i] = input%10;
    input = input / 10;
  }

  return 0;
}

int count_hit(int ans[], int input[]) {
  int i, hit_num = 0;
  for(i = 0; i < DIGITS_NUM; i++) {
    if(input[i] == ans[i])
      hit_num++;
  }

  return hit_num;
}

int count_blow(int ans[], int input[]) {
  int i, j, blow_num = 0;
  for(i = 0; i < DIGITS_NUM; i++) {
    for(j = 0; j < DIGITS_NUM; j++) {
      if(ans[i] == input[j]) {
        if(i != j) {
          blow_num++;
        }
      }
    }
  }

  return blow_num;
}

int main(void) {
	int ans[DIGITS_NUM];
	int i, j;
	int hit_num = 0, blow_num = 0;

	srand((unsigned)time(NULL));

  // 1. 答えとなる数を設定する
	generate_ans(ans);

	while(1) {
		int input_array[DIGITS_NUM];
		hit_num = 0, blow_num = 0;
    
    // 2. プレイヤーからの数の入力を行う
    input_num(input_array);
    // 3. 入力された数のヒット数を計算
		hit_num = count_hit(ans, input_array);
    // 4. 入力された数のブロー数を計算
    blow_num = count_blow(ans, input_array);

    // 5. 結果を表示
		if(hit_num == DIGITS_NUM) {
			printf("正解!\n");
			break;
		}

		printf("hit: %d, blow: %d\n\n", hit_num, blow_num);
	}
	return 0;
}

```

注目してほしいのはmain関数の中です。だいぶ簡潔になっていると思います。
1.から4.までの処理をすべて関数化しました。
次に4つの関数それぞれの関数原形宣言を書きます。
```func_prototype.c
void generate_ans(int ans[]);
int input_num(int input_array[]);
int count_hit(int ans[], int input[]);
int count_blow(int ans[], int input[]);
```

いきなりこんなに関数定義されても理解できない!という人はネット等で関数の問題を見つけて解くなどしてある程度関数に慣れてから挑戦してみてください。

#### generate_ans

順に説明していきます。まずはgenerate_ans関数です。この関数はint型配列の引数ansを一つ持っています。配列の引数を宣言するときには、名前の後ろに[]を付けます。要素数は書かないようにしてください。戻り値はvoid、つまり何も返さないということです。
では関数本体を見ていきたいのですが、名前からどんな処理をする関数かある程度察しがつきます。この関数は答えを生成する関数です。関数本体では、ランダムにDIGITS_NUM桁の重複なしの数字を生成して、ansに設定します。ここでなにか疑問に思うことはありませんか。ansは引数なので、いくら関数内でその値を変更しても、呼び出し側の変数には関係ないから、main関数内のansは変わらないはずじゃないでしょうか。しかし大丈夫です。実は配列を引数にした場合は、例外なのです(本当はこれは誤解を招く表現ではありますが今はその理解でいいです)。関数内で値を変更すると、呼び出し側の変数の中身の変わります。

### input_num

input_numは、input_arrayを引数として持っていて、関数内部でscanfにより読み取った値をinput_arrayに格納します。generate_ansと同様に、受け取った引数に対して処理を行う関数なので、戻り値はvoidでいいはずです。しかし、戻り値はintになっていて、関数本体の最後では、return 0;で0を返しています。いまはまだ意味のない返り値ですが、今後さらに機能を追加して、入力された数が正しい数だったかどうかを判定するためにこの戻り値は使用する予定です。

### count_hit, count_blow

どちらも引数としてans、inputを持っています。count_hit(count_blow)は、これらの引数をもとにヒット数(ブロー数)を計算し、計算した値を返しています。関数本体は、前のコードからそのまま移植したような形です。

## エラー処理を追加